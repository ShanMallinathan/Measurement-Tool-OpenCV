#include <opencv2\opencv.hpp>
#include <cmath> //to calculate distance

using namespace cv;

using namespace std;

//Class containing all files related to image processing and coordinate mapping
class Measuring_tool
{
public:

	static void click_event(int event, int x, int y, int flags, void* userdata);
	Mat Binary_converter(Mat image);
	vector<double> FindContours(Mat image);
	void display_readings(Mat image, double perimeter, string winname, string textn, string h2);
	double distance(vector<Point> P);
	//functions to access private variables
	void No_crop(int x, int y) { crop_coord = { {0, 0}, {y, x} }; } //no crop initially
	vector<Point> Return_crop_coord() { return crop_coord; } //to get crop_coord
	void set_measurement(int x1, int y1, int x2, int y2) { measurement = { {x1, y1}, {x2, y2} }; } 
	vector<Point> Return_measurement() { return measurement; } //returning click values of post calibration
	void set_crop_flag(bool feedback) { crop_flag = feedback; }
	bool Return_crop_flag() { return crop_flag; }
	bool Return_measure_flag() { return measure_flag; }

private:

	//vector to store coordinates for image cropping
	static vector<Point> crop_coord; 
	//Measurement Coordinates
	static vector<Point> measurement;
	//To flag if cropping is done
	static bool crop_flag;
	//To flag if 2 clicks done for measurement
	//used for setting the measurent points to (-1, -1) once 2 points are collected
	static bool measure_flag;
	
};

//initialisation of the static variables
vector<Point> Measuring_tool::crop_coord = { {0, 0}, {0, 0} };
vector<Point> Measuring_tool::measurement = { {-1, -1}, {-1, -1} };
bool Measuring_tool::crop_flag = true;
bool Measuring_tool::measure_flag = false;

//Function to crop image based on user mouse click events
void Measuring_tool::click_event(int event, int x, int y, int flags, void* userdata)
{
	Mat img = *(Mat*)userdata;

	//To perfrom cropping
	if (crop_flag)
	{
		//First Point
		if (event == EVENT_LBUTTONDOWN)
		{
			crop_coord[0].x = x;
			crop_coord[0].y = y;
		}
		//Below code is executed only of Left mouse is clicked
		//To dynamically draw rectangle as cropping is done
		else if ((event == EVENT_MOUSEMOVE) && (flags == EVENT_FLAG_LBUTTON))
		{
			crop_coord[1].x = x;
			crop_coord[1].y = y;
		}
		//second Point
		else if (event == EVENT_LBUTTONUP)
		{
			crop_coord[1].x = x;
			crop_coord[1].y = y;
			crop_flag = false;

		}
		
	}

	//Once the cropping is done - click to measure mode
	else 
	{
		//the measurement values are set to (-1, -1) every iteration 
		//Fiirst point
		if (event == EVENT_LBUTTONDOWN && (measurement[0].x == -1 && measurement[0].y == -1))
		{
			measurement[0].x = x;
			measurement[0].y = y;
			measure_flag = false;
		}
		//second point
		else if (event == EVENT_LBUTTONDOWN && (measurement[1].x == -1 && measurement[1].y == -1))
		{
			measurement[1].x = x;
			measurement[1].y = y;
			measure_flag = true;//This enables setting measurement points as (-1, -1)
		}
	}

};


//Converting the input image to grayscale, binary and detect edges using Canny
Mat Measuring_tool::Binary_converter(Mat image)
{
	Mat grey, binary, edges;
	cvtColor(image, grey, COLOR_BGR2GRAY);
	threshold(grey, binary, 85, 255, THRESH_BINARY_INV | THRESH_OTSU);//Applying threshold for binary
	Canny(binary, edges, 50, 150);
	return edges;
}


//Function to find the contours of the borders generated by binary_converter and find its perimeter
vector<double> Measuring_tool::FindContours(Mat image)
{
	vector<vector<Point>> feature; //to get the locations of the contours
	vector<Vec4i> feature_list; //The index of contours
	Point2f edges[4]; //To store the edges of the rotated rectangle 
	Mat binary = Binary_converter(image);//to convert to binary
	//Finding only the external contours
	findContours(binary, feature, feature_list, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
	RotatedRect rectangle;
	Mat contour = image.clone();
	double Width = 0.0, Height =0.0, perimeter = 0.0;

	//Loop togo tggrough all the contours
	for (int k = 0; k < feature.size(); k++)
	{
		rectangle = minAreaRect(feature[k]); //get the smallest rectangle that covers the contour
		rectangle.points(edges);
		
		for (int i = 0; i < 4; i++) //For drawing the rectangle
		{
			//Conditions to retrieve only larger rectangles
			if (rectangle.size.width > image.cols /10 && rectangle.size.height > image.rows /10)
			{
				Width = rectangle.size.width;
				Height = rectangle.size.height;
				line(image, edges[i], edges[(i + 1) % 4], Scalar(255, 120, 0), 2);
				perimeter = 2 * (Width + Height);
			}
		}
	}
	if (Width > Height) //To swap the value when width is bigger than height
	{
		double temp = Width;
		Width = Height;
		Height = temp;
	}

	return { Width, Height, perimeter };
}


//Function to display images and measured values
void Measuring_tool::display_readings(Mat image, double perimeter, string winname, string text, string h2)
{
	Mat3b instrument(image.rows, 350, Vec3b(0, 0, 0)); //Section to display all the values (Right console)
	Mat3b Measurement_tool(image.rows, (image.cols+350), Vec3b(0,0,0));//For window that combines image and reading display
	//For printing in the instrument subwindow
	if (perimeter != -1) 
	{
		string peri_char = to_string(perimeter);
		text = text + peri_char;
	}
	//List of sentences to be printed in the console
	string heading = "Measurement tool by Shanthinath Mallinathan";
	string print_text[8] = { heading,
							h2,
							text,
							"Instruction",
							"Escape to skip cropping or exit program",
							"Press 'o' for circle radius",
							"Press 'r' for rectangle perimeter",
							"Press any other key for manual measurement"
							};
	Point pos(10, 10); //Header position
	putText(instrument, heading, pos, FONT_HERSHEY_SIMPLEX, 0.45, Scalar(255, 255, 255), 0.35);
	//Loop to print all the readings and instruction in the console
	for(int i = 1; i<8; i++)
	{
		pos.y += 20;
		putText(instrument, print_text[i], pos, FONT_HERSHEY_SIMPLEX, 0.4, Scalar(255, 255, 255), 0.2);

	}
	//copying both image and instrument matrix into Measurement_tool
	image.copyTo(Measurement_tool(Rect(0, 0, image.cols, image.rows)));
	instrument.copyTo(Measurement_tool(Rect(image.cols, 0, 350, image.rows)));
	namedWindow(winname);
	imshow(winname, Measurement_tool);	
}

//Program to find the euclidian distance between 2 points
double Measuring_tool::distance(vector<Point> P)
{
	return sqrt(pow((P[0].x - P[1].x), 2) + pow((P[0].y - P[1].y), 2)); //distance formula
}

//Not a member function of Measuring_tool
//Program to crop and return the parent image along woth drawind dynamic rectangles
Mat crop_image(Mat image)
{
	Mat  image1;
	Measuring_tool measure; //object ofMeasuring_tool
	vector<Point> crop; //Cropping coordinates
	measure.No_crop(image.rows, image.cols); //no cropping by default
	while (measure.Return_crop_flag())
	{
		image1 = image.clone();
		crop = measure.Return_crop_coord();
		rectangle(image1, crop[0], crop[1], Scalar(255, 170, 0), 2); //Draw rectangle
		measure.display_readings(image1, -1, "Measurement Window", "Left click-Drag-Release to crop or escape to skip.", "Cropping Window:");
		if (waitKey(1) == 27) break; //Break when escape key is pressed
	}
	cout << "\n Working...\n\n\n";
	//cropping the image
	Mat Crop_image = image.clone();
	//Cropping of the image
	Crop_image = Crop_image(Rect(crop[0], crop[1]));
	return Crop_image;
}

int main() 
{

	Mat image, Crop_image;
	double perimeter = -1.0, dist = 0.0, calib_factor = 1.0, manual_dist = 0.0;
	bool flag = true;
	Measuring_tool measure;
	int choice = 1, keystroke = 0, input_mode = -1;
	//Change the below value to change the image - Make sure that the image
	//is stored in both resource folder and the folder that contains this source code
	string source_image = "Sample_4.jpg";
	//Change the below value to change the camera
	int port_value = 0;

	//Input mode selection
	cout << "Measuring Tool Using OpenCV C++ By Shanthinath\n";
	cout << "Main Menu\n";
	cout << "1. Use live feed camera\n";
	cout << "2. Image from resource folder\nYour Choice (1/2): ";
	cin >> input_mode;

	if (!(input_mode == 1 || input_mode == 2))
	{
		cout << "Invalid selection!!\nExiting...";
		return -1;
	}

	if (input_mode == 2)
		cout << "\nTo add new image, add the image into resource folder and \nappend the source_image value to name of the image\n";
	else
		cout << "\nTo change to different camera, change the port_value \n";

	//Calibration mode selection
	//option 4 can be best suited for poor lighting conditons and contrast
	cout << "\nMeasuring Tool Using OpenCV C++ By Shanthinath\n";
	cout << "Main Menu\n";
	cout << "1. Calibrate using 1 pound coin\n";
	cout << "2. Calibrate using ATM card\n";
	cout << "3. Using provided template\n";
	cout << "4. Manual calibratio using click events\nYour Choice (1 - 4): ";
	cin >> choice;
	if (!(choice == 1 || choice == 2 || choice == 3 || choice == 4))
	{
		cout << "Invalid selection!!\nExiting...";
		return -1;
	}

	if (choice == 4)
	{
		cout << "\n\n\nManual calibration\n\n\n";
		cout << "Enter the distance of object to be used for calibration: ";
		cin >> manual_dist;
		measure.set_crop_flag(false);
	}

	//Initiate webcam
	VideoCapture cap(port_value);
	if (input_mode == 1)
	{

		if (!cap.isOpened())
		{
			cout << "Cannot Open the File";
			cin.get();
			return -1;
		}
		//Place the calibrating object and press escape to enable cropping
		while (waitKey(1) != 27)
		{
			cap.read(image);
			measure.display_readings(image, -1, "Measurement Window", "Place the standard object", "Press escape once placed");

		}
	}
	else //Static image mode
	{
		cap.release();
		cout << "\n\n\nStatic image mode\n\n\n";
		image = imread(source_image);
		if (image.empty())
		{
			cout << "Error loading image. Please check the instructions or comments for more details ";
			return -1;//exit code with -1 status
		}
	}
	Mat image1 = image.clone();

	namedWindow("Measurement Window");
	//Mouse callback function for cropping the image - press any key without clicking to override cropping
	setMouseCallback("Measurement Window", Measuring_tool::click_event, &image);
	
	//Get perimeter based on calibration mode
	if (choice == 1)//1 pound coin
	{
		Crop_image = crop_image(image1);
		perimeter = measure.FindContours(Crop_image)[0];//To get the smallest side eliminating shadows
		calib_factor = perimeter / 23.43; //23.43 is the diameter of the coin
	}

	else if (choice == 2)//ATM card/ID card
	{
		Crop_image = crop_image(image1);
		perimeter = measure.FindContours(Crop_image)[2];// To find the contours and perimeter
		calib_factor = perimeter / 279.16; //279.16mm - actual perimeter ATM card
	}
	else if (choice == 3)//Printed template
	{
		Crop_image = crop_image(image1);
		perimeter = measure.FindContours(Crop_image)[2];// To find the contours and perimeter
		calib_factor = perimeter / 822; //822mm - actual perimeter of outer rectangle
	}
	else if (choice == 4)//Manual calibration - advised only for extreme lighting conditions
	{
		measure.display_readings(image1, -1, "Measurement Window", "Click the endpoints and press any key", "Manual Mode");
		waitKey(0);
		vector<Point> manual_coord = measure.Return_measurement();
		perimeter = measure.distance(manual_coord);
		calib_factor = perimeter / manual_dist;
		measure.set_measurement(-1, -1, -1, -1); //Set measurement points to initial values
	}

	if (choice != 4)//Only for autonomous calibration modes
	{
		measure.display_readings(Crop_image, -1, "Measurement Window", "Calibration Done - Press any key", "Success!");
		waitKey(1000);
	}
	
	//Measurement window - Press escape to quit
	while (flag)
	{
		if(input_mode == 1) //if webcam feed is used
			cap.read(image);
		setMouseCallback("Measurement Window", Measuring_tool::click_event, &image);
		keystroke = waitKey(10);  //to change circle radius and rectangle perimeter modes
		measure.display_readings(image, dist, "Measurement Window", "The distance is : ", "Manual measurement");
		switch (keystroke) 
		{
		case 111: //circle mode
		case 79:
		{
			measure.set_crop_flag(true);
			Crop_image = crop_image(image.clone());
			dist = measure.FindContours(Crop_image)[0]/2;
			dist /= calib_factor; //converting pixel space to mm
			measure.display_readings(image, dist, "Measurement Window", "The radius is : ", "Circle Mode");
			cout << "\n\nCircle Mode\nThe radius is: " << dist;
			waitKey(700);
			break;
		}
		case 114: //rectanle mode
		case 82:
		{
			measure.set_crop_flag(true);
			Crop_image = crop_image(image.clone());
			vector<double> param = measure.FindContours(Crop_image);
			dist = param[1]/calib_factor;
			double width = param[0]/calib_factor;
			measure.display_readings(image, dist, "Measurement Window", "The length is : ", "Rectangle Mode");
			cout << "\n\nRectangle Mode";
			cout << "\n The length is: " << dist;
			cout << "\n The width is: " << width;
			waitKey(700);
			break;
		}
		case 27: //Exit once escape key is pressed
		{
			measure.display_readings(image, -1, "Measurement Window", "Task terminated by user!", "Exiting!");
			waitKey(500);
			flag = false; //to terminate the while loop
			cout << "\n\nCode Terminated";
			break;
		}
		default: //default - click to measure mode
		{
			measure.set_crop_flag(false);
			vector<Point> m_coord = measure.Return_measurement();
			if (m_coord[1] != Point(-1, -1)) //To check of the second point is clicked
			{
				dist = measure.distance(m_coord);
				dist /= calib_factor;
				measure.display_readings(image, dist, "Measurement Window", "The distance is : ", "Manual measurement");
				waitKey(500);
				cout << "\n\nThe measured distance is: " << dist;
			}
			if(measure.Return_measure_flag()) //To set the measurement poins to default so as to pick the correct point next time
				measure.set_measurement(-1, -1, -1, -1);
			break;
		}
		}
	}
	destroyAllWindows();
	return 0;

}